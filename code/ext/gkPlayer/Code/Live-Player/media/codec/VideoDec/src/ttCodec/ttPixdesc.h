#ifndef __TTPOD_TT_PIXDESC_H_
#define __TTPOD_TT_PIXDESC_H_

#include <inttypes.h>

#include "ttAttributes.h"
#include "ttPixfmt.h"

typedef struct AVComponentDescriptor {
    /**
     * Which of the 4 planes contains the component.
     */
    uint16_t plane        : 2;

    /**
     * Number of elements between 2 horizontally consecutive pixels minus 1.
     * Elements are bits for bitstream formats, bytes otherwise.
     */
    uint16_t step_minus1  : 3;

    /**
     * Number of elements before the component of the first pixel plus 1.
     * Elements are bits for bitstream formats, bytes otherwise.
     */
    uint16_t offset_plus1 : 3;

    /**
     * Number of least significant bits that must be shifted away
     * to get the value.
     */
    uint16_t shift        : 3;

    /**
     * Number of bits in the component minus 1.
     */
    uint16_t depth_minus1 : 4;
} AVComponentDescriptor;

/**
 * Descriptor that unambiguously describes how the bits of a pixel are
 * stored in the up to 4 data planes of an image. It also stores the
 * subsampling factors and number of components.
 *
 * @note This is separate of the colorspace (RGB, YCbCr, YPbPr, JPEG-style YUV
 *       and all the YUV variants) AVPixFmtDescriptor just stores how values
 *       are stored not what these values represent.
 */
typedef struct AVPixFmtDescriptor {
    const char *name;
    uint8_t nb_components;  ///< The number of components each pixel has, (1-4)

    /**
     * Amount to shift the luma width right to find the chroma width.
     * For YV12 this is 1 for example.
     * chroma_width = -((-luma_width) >> log2_chroma_w)
     * The note above is needed to ensure rounding up.
     * This value only refers to the chroma components.
     */
    uint8_t log2_chroma_w;  ///< chroma_width = -((-luma_width )>>log2_chroma_w)

    /**
     * Amount to shift the luma height right to find the chroma height.
     * For YV12 this is 1 for example.
     * chroma_height= -((-luma_height) >> log2_chroma_h)
     * The note above is needed to ensure rounding up.
     * This value only refers to the chroma components.
     */
    uint8_t log2_chroma_h;
    uint8_t flags;

    /**
     * Parameters that describe how pixels are packed.
     * If the format has 2 or 4 components, then alpha is last.
     * If the format has 1 or 2 components, then luma is 0.
     * If the format has 3 or 4 components,
     * if the RGB flag is set then 0 is red, 1 is green and 2 is blue;
     * otherwise 0 is luma, 1 is chroma-U and 2 is chroma-V.
     */
    AVComponentDescriptor comp[4];

    /**
     * Alternative comma-separated names.
     */
    const char *alias;
} AVPixFmtDescriptor;

/**
 * Pixel format is big-endian.
 */
#define TTV_PIX_FMT_FLAG_BE           (1 << 0)
/**
 * Pixel format has a palette in data[1], values are indexes in this palette.
 */
#define TTV_PIX_FMT_FLAG_PAL          (1 << 1)
/**
 * All values of a component are bit-wise packed end to end.
 */
#define TTV_PIX_FMT_FLAG_BITSTREAM    (1 << 2)
/**
 * Pixel format is an HW accelerated format.
 */
#define TTV_PIX_FMT_FLAG_HWACCEL      (1 << 3)
/**
 * At least one pixel component is not in the first data plane.
 */
#define TTV_PIX_FMT_FLAG_PLANAR       (1 << 4)
/**
 * The pixel format contains RGB-like data (as opposed to YUV/grayscale).
 */
#define TTV_PIX_FMT_FLAG_RGB          (1 << 5)
/**
 * The pixel format is "pseudo-paletted". This means that FFmpeg treats it as
 * paletted internally, but the palette is generated by the decoder and is not
 * stored in the file.
 */
#define TTV_PIX_FMT_FLAG_PSEUDOPAL    (1 << 6)
/**
 * The pixel format has an alpha channel.
 */
#define TTV_PIX_FMT_FLAG_ALPHA        (1 << 7)

#if TT_API_PIX_FMT
/**
 * @deprecated use the TTV_PIX_FMT_FLAG_* flags
 */
#define PIX_FMT_BE        TTV_PIX_FMT_FLAG_BE
#define PIX_FMT_PAL       TTV_PIX_FMT_FLAG_PAL
#define PIX_FMT_BITSTREAM TTV_PIX_FMT_FLAG_BITSTREAM
#define PIX_FMT_HWACCEL   TTV_PIX_FMT_FLAG_HWACCEL
#define PIX_FMT_PLANAR    TTV_PIX_FMT_FLAG_PLANAR
#define PIX_FMT_RGB       TTV_PIX_FMT_FLAG_RGB
#define PIX_FMT_PSEUDOPAL TTV_PIX_FMT_FLAG_PSEUDOPAL
#define PIX_FMT_ALPHA     TTV_PIX_FMT_FLAG_ALPHA
#endif

#if TT_API_PIX_FMT_DESC
/**
 * The array of all the pixel format descriptors.
 */
extern attribute_deprecated const AVPixFmtDescriptor ttv_pix_fmt_descriptors[];
#endif




/**
 * @return a pixel format descriptor for provided pixel format or NULL if
 * this pixel format is unknown.
 */
const AVPixFmtDescriptor *ttv_pix_fmt_desc_get(enum TTPixelFormat pix_fmt);



/**
 * Utility function to access log2_chroma_w log2_chroma_h from
 * the pixel format AVPixFmtDescriptor.
 *
 * See ttv_get_chroma_sub_sample() for a function that asserts a
 * valid pixel format instead of returning an error code.
 * Its recommended that you use ttcodec_get_chroma_sub_sample unless
 * you do check the return code!
 *
 * @param[in]  pix_fmt the pixel format
 * @param[out] h_shift store log2_chroma_w
 * @param[out] v_shift store log2_chroma_h
 *
 * @return 0 on success, AVERROR(ENOSYS) on invalid or unknown pixel format
 */
int ttv_pix_fmt_get_chroma_sub_sample(enum TTPixelFormat pix_fmt,
                                     int *h_shift, int *v_shift);

/**
 * @return number of planes in pix_fmt, a negative AVERROR if pix_fmt is not a
 * valid pixel format.
 */
int ttv_pix_fmt_count_planes(enum TTPixelFormat pix_fmt);



#endif /* __TTPOD_TT_PIXDESC_H_ */
